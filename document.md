# RISC-V CPU

*姚远 518030910436*



## 我的设计

#### 五级流水

CPU以五级流水的形式实现了指令集并行。

IF、ID、EX、MEM都是组合电路，当激发端信号产生变化时，立即计算并产生结果。

IF/ID、ID/EX、EX/MEM、MEM/WB是时序电路，通过时序电路将整个流水线划分为五级。

其中，考虑到各级工作量应尽可能均衡，我将分支指令的判断放在了EX阶段而非ID阶段。

#### Data-foward

五级流水带来指令并行的同时，也带来的数据冒险。

我在ID模块中添加了数据转发的接口，使后续流水线的数据能够“走捷径”转发到ID环节，不用暂停整条流水线。

但对于涉及到内存读入的指令，则ID会发起stall请求，等待数据从内存接口取出后再继续。

#### 内存接口管理

由于助教提供的接口特殊，我采用了一块专用的模块mem_ctrl管理内存接口。

具体实现为一个时序电路的有限状态自动机，对外发送inst_available、data_available、addr_needed等控制信息来与外界进行交互。



## 特色

#### ICache

采用DM的映射方式的icache。

出于不想产生锁存器的考虑，我的cache的更新使用了时序电路。

#### Dcache

采用DM映射方式，write through策略的dcache。

虽然是write through策略，但我特别设计了写穿的时机，使得dcache数据写入内存的同时流水线可以继续运行而不必等待。考虑到内存接口在cache充分大后使用频率较低，我采用的特殊写穿策略和写回策略的性能基本是相近的。

此外，我的dcache实现中还针对了内存接口的特点对不同大小的数据块（1byte、2byte、4byte）特殊处理。这意味着我每次从内存接口取东西时不是取一个block，而是只取我需要的byte，然后部分存在我的内存块中。因此，在同一个内存块中可能出现部分数据正确部分数据错误的情况，为此我为每个byte的数据添加了valid位，当需要读dcache的时候应先判断该块数据是否全部valid。

#### 内存接口预取下一条指令

由于内存接口特性原因，一条4byte的指令的读取全流程远长于4个周期。因此，我对内存管理模块进行了特殊的设计，在一条指令读取的空闲期静态预测下一条指令的地址（PC+4），并将下一条指令预取至一块buffer中。如果预测正确了，自动跳过某些自动机状态。

#### BTB

动态分支预测配合branch target buffer，可以在IF阶段实现分支预测，从而在分支指令中节省2个周期。具体实现为2-bit predictor。

BTB主要与三个模块进行交互：IF、EX、PC_REG，其中与EX的交互是时序电路，与IF、PC_REG的交互是组合电路。

当IF收到地址后，立刻将地址转发给BTB，并进行检索。BTB若发现该地址有记录，则根据记录结果进行预测，并把预测结果发送给PC_REG。

EX遇到分支指令时，会将计算结果转发给BTB，用于更新预测器的数据。

#### FPGA 上板

在消除了所有的锁存器后，我的CPU成功在FPGA上运行，频率135MHz。



## 遇到的问题

#### 上板困难

一开始设计CPU时，我没有按照电路的思想设计，而只是按写代码的方式来写，这为我上板带来了很多麻烦，具体不加赘述。

在消除了所有critical warning和latch后，最终上板成功。

#### 内存接口代码问题

0x30000、0x30004为组合电路，在连续多cycle保持相同的值时无法会吞字符。此bug我调试了很久才找到。

我尝试修改hci.v，使内存接口能接受时序信号，但效果不理想，未能成功。

最终解决方法是我拉开了load指令的距离，使与内存接口的交互不连续进行。



## 截图留念

![image-20191231172440773](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20191231172440773.png)